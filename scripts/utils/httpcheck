#!/usr/bin/env bash
# Test HTTP/HTTPS endpoint with standardized output
# Usage: httpcheck URL [TIMEOUT]
#
# Exit codes:
#   0 - PASS: Request successful (any HTTP response received)
#   1 - FAIL: Request failed (connection error, timeout, etc.)
#   2 - ERROR: Missing required arguments

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/../common.sh"

if [[ $# -lt 1 ]]; then
    cat >&2 << EOF
Usage: ${0##*/} URL [TIMEOUT]

Test HTTP/HTTPS endpoint with standardized output.

Arguments:
  URL         URL to test
  TIMEOUT     Timeout in seconds (default: 5)

Output format:
  HTTP <code> - <bytes> bytes

Exit codes:
  0 - PASS: Request successful (any HTTP response received)
  1 - FAIL: Request failed (connection error, timeout, etc.)
  2 - ERROR: Missing required arguments

Examples:
  ${0##*/} https://grafana.erauner.dev
  ${0##*/} http://10.10.0.1 10

EOF
    exit "${EXIT_ERROR}"
fi

URL="$1"
TIMEOUT="${2:-5}"

# Test endpoint with standardized output format
# Use -k to ignore certificate errors (self-signed certs)
# Use -L to follow redirects
# NOTE: Do NOT use -f (--fail) because we want ANY HTTP response to be considered
# a successful connection. The caller can use validate: regex to check status codes.
HTTP_CODE=$(curl -sSLk -m "${TIMEOUT}" -o /dev/null \
    -w '%{http_code}' \
    "${URL}" 2>/dev/null) || {
    echo "HTTP connection failed to ${URL}" >&2
    exit "${EXIT_FAILURE}"
}

# Any HTTP response means the connection succeeded
if [[ "${HTTP_CODE}" =~ ^[0-9]+$ ]] && [[ "${HTTP_CODE}" -gt 0 ]]; then
    echo "HTTP ${HTTP_CODE} - connection successful"
    exit "${EXIT_SUCCESS}"
else
    echo "HTTP connection failed to ${URL}" >&2
    exit "${EXIT_FAILURE}"
fi
